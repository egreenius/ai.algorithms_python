"""
2. Написать программу сложения и умножения двух шестнадцатеричных чисел. При этом каждое число представляется как
массив, элементы которого — цифры числа.
Например, пользователь ввёл A2 и C4F. Нужно сохранить их как [‘A’,
‘2’] и [‘C’, ‘4’, ‘F’] соответственно. Сумма чисел из примера: [‘C’, ‘F’, ‘1’], произведение - [‘7’, ‘C’, ‘9’, ‘F’,
‘E’].
Примечание: Если воспользоваться функциями hex() и/или int() для преобразования систем счисления,
задача решается в несколько строк. Для прокачки алгоритмического мышления такой вариант не подходит. Поэтому
использование встроенных функций для перевода из одной системы счисления в другую в данной задаче под запретом.
"""

from collections import deque


def sum_hex_d(x, y, p=0):  # функция сложения шестнадцатеричных цифр. x, y в символьном виде
    a = deque('0123456789ABCDEF')
    b = deque('0123456789ABCDEF0123456789ABCDEF')
    i = a.index(x) + a.index(y) + p
    if i > 15:
        return 1, b[i]
    else:
        return 0, b[i]


def sum_hex(x, y):  # функция сложения шестнадцатеричных чисел
    c = deque()
    # приводим исходные данные к представлению массива шестнадцатеричных цифр
    x = tuple(x)
    y = tuple(y)
    # более длинное число располагаем сверху в виртуальном сложении столбиком
    if len(x) < len(y):
        x, y = y, x
    # разворачиваем массивы для удобства
    x = x[::-1]
    y = y[::-1]

    p = 0
    for i, v in enumerate(x):  # основной цикл сложения столбиком
        if i > (len(y) - 1):
            if p:
                res = sum_hex_d(v, '1', 0)
                c.appendleft(res[1])
                p = res[0]
            else:
                c.appendleft(v)
        else:
            res = sum_hex_d(v, y[i], p)
            c.appendleft(res[1])
            p = res[0]
    if p:
        c.appendleft('1')  # если после цикла "в уме" осталась единичка, добавляем ее слева
    return list(c)


def multi_hex(x, y):  # функция умножения шестнадцатеричных чисел
    a = deque('0123456789ABCDEF')
    x = tuple(x)
    y = tuple(y)

    # нас интересует меньшее число
    if len(x) > len(y):
        x, y = y, x
    # разворачиваем меньшее число
    x = x[::-1]

    spam_r = []  # здесь будем собирать результат умножения большего числа, на каждую цифру меньшего
    for i, v in enumerate(x):  # основной цикл поэлементного умножения
        spam = y
        for _ in range(a.index(v)-1):
            spam = sum_hex(spam, y)
        for _ in range(i):
            spam.append('0')
        spam_r.append(spam)
    # print(f'spam = {spam}')
    # print(f'spam_r = {spam_r}')
    res = spam_r[0]
    for i in range(len(spam_r)-1):  # цикл сложения чисел, полученных в результате поэлементного умножения
        res = sum_hex(res, spam_r[i+1])
    return res


#  Tecт
h_x = 'A2'
h_y = 'C4F'
assert sum_hex(h_x, h_y) == ['C', 'F', '1']
assert multi_hex(h_x, h_y) == ['7', 'C', '9', 'F', 'E']
print('Тест пройден!')
print()
h_x = input('Введите первое шестнадцатеричное число: ').upper()
h_y = input('Введите второе шестнадцатеричное число: ').upper()
print('Сложение:')
print(f'"{h_x}" + "{h_y}" = "{"".join(sum_hex(h_x, h_y))}"')
print('Умножение')
print(f'"{h_x}" * "{h_y}" = "{"".join(multi_hex(h_x, h_y))}"')


