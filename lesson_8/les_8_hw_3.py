"""
3. Написать программу, которая обходит не взвешенный ориентированный граф без петель, в котором все вершины связаны,
по алгоритму поиска в глубину (Depth-First Search).
Примечания:
a. граф должен храниться в виде списка смежности;
b. генерация графа выполняется в отдельной функции, которая принимает на вход число вершин.
"""
import random
from collections import deque


def create_graph(num):
    g_lst = {}  # здесь будет наш список смежности
    v_lst = [None] * num  # здесь будем накапливать список вершин, с которыми есть связь
    d = deque([el for el in range(num)])  # создадим очередь, по ней мы будем генерить связи

    for i in range(num):  # организуем цикл создания связей для каждой вершины
        n = random.randint(1, num - 1)  # узнаем сколько связей имеет данная вершина
        v_lst[i] = set()  # создаем пустое множество для заполнения списком вершин

        k = 0
        while k < n or len(v_lst[i]) == 0:  # узнаем, с какими вершинами связана данная
            vertex = random.choice(list(d)[1:])  # случайно выберем вершину для связи из очереди, исключая саму себя
            one_way = random.choice([True, False])  # зададим тип связи - односторонняя или двусторонняя
            if vertex > i:
                v_lst[i].add(vertex)  # если вершина (vertex) больше текущей, добавляем в список связи без вопросов
            elif i not in g_lst[vertex]:
                v_lst[i].add(vertex)  # для вершин, меньше текущей, при отсутствии связи - добавляем в список
            elif not one_way:
                v_lst[i].add(vertex)  # если связь уже есть, проверяем тип связи, если односторонняя - пропускаем
            elif one_way:
                    print(f'One way: вершины {i} и {vertex}. one way = {one_way}')
            k += 1

        g_lst[i] = v_lst[i]  # заполняем список смежности
        d.rotate(-1)
    return g_lst

"""
Алгоритм "Поиск в глубину"
1. Начинаем обход с точки старта. 
2. Помещаем точку старта в список посещенных
3. Обходим в цикле все смежные вершины, исключая посещенные
4. Для каждого эелемента в цикле рекурсивно повторяем шаги 1 - 3, помещая в точку старта данные элемент
"""


def dfs(graph, start, visited=None):  # функция вернет список доступных вершин из точки старта
    if visited is None:
        visited = set()
    visited.add(start)  # добавляем вершину в посещенные
    for next in graph[start] - visited:  # рассматриваем только не посещенные элементы
        dfs(graph, next, visited)  # помещаем в точку старта рассматриваемый элемент, и рекурсивно вызываем функцию
        # поиска
    return visited


n = int(input('Задайте количество вершин: '))
g = create_graph(n)
print('*' * 50)
print(f'Наш ориентированный граф с количеством вершин {n}: ')
for k, v in g.items():
    print(f'{k}: {v}')

print('*' * 50)
# visited = dfs(g, 1)
print()
for i in range(n):
    print(f'Список доступных вершин из вершины {i}: {dfs(g, i)}')
